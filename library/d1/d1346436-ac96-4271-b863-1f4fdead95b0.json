{
  "__type__": "cc.EffectAsset",
  "_name": "builtin-particle",
  "_objFlags": 0,
  "_native": "",
  "techniques": [
    {
      "name": "add",
      "passes": [
        {
          "rasterizerState": {
            "cullMode": 0
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 2,
                "blendDst": 1,
                "blendSrcAlpha": 2,
                "blendDstAlpha": 1
              }
            ]
          },
          "program": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
          "depthStencilState": {
            "depthTest": true,
            "depthWrite": false
          },
          "properties": {
            "mainTexture": {
              "value": "grey",
              "type": 28
            },
            "mainTiling_Offset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "frameTile_velLenScale": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "tintColor": {
              "value": [
                0.5,
                0.5,
                0.5,
                0.5
              ],
              "inspector": {
                "type": "color"
              },
              "type": 16
            }
          }
        }
      ]
    },
    {
      "name": "alpha-blend",
      "passes": [
        {
          "rasterizerState": {
            "cullMode": 0
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 1,
                "blendDst": 4,
                "blendSrcAlpha": 1,
                "blendDstAlpha": 4
              }
            ]
          },
          "program": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
          "depthStencilState": {
            "depthTest": true,
            "depthWrite": false
          },
          "properties": {
            "mainTexture": {
              "value": "grey",
              "type": 28
            },
            "mainTiling_Offset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "frameTile_velLenScale": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "tintColor": {
              "value": [
                0.5,
                0.5,
                0.5,
                0.5
              ],
              "inspector": {
                "type": "color"
              },
              "type": 16
            }
          }
        }
      ]
    },
    {
      "name": "add-multiply",
      "passes": [
        {
          "rasterizerState": {
            "cullMode": 0
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 1,
                "blendDst": 4,
                "blendSrcAlpha": 1,
                "blendDstAlpha": 4
              }
            ]
          },
          "program": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply",
          "depthStencilState": {
            "depthTest": true,
            "depthWrite": false
          },
          "properties": {
            "mainTexture": {
              "value": "grey",
              "type": 28
            },
            "mainTiling_Offset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "frameTile_velLenScale": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "tintColor": {
              "value": [
                0.5,
                0.5,
                0.5,
                0.5
              ],
              "inspector": {
                "type": "color"
              },
              "type": 16
            }
          }
        }
      ]
    },
    {
      "name": "add-smooth",
      "passes": [
        {
          "rasterizerState": {
            "cullMode": 0
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 1,
                "blendDst": 4,
                "blendSrcAlpha": 1,
                "blendDstAlpha": 4
              }
            ]
          },
          "program": "builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth",
          "depthStencilState": {
            "depthTest": true,
            "depthWrite": false
          },
          "properties": {
            "mainTexture": {
              "value": "grey",
              "type": 28
            },
            "mainTiling_Offset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "frameTile_velLenScale": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            }
          }
        }
      ]
    },
    {
      "name": "premultiply-blend",
      "passes": [
        {
          "rasterizerState": {
            "cullMode": 0
          },
          "blendState": {
            "targets": [
              {
                "blend": true,
                "blendSrc": 1,
                "blendDst": 4,
                "blendSrcAlpha": 1,
                "blendDstAlpha": 4
              }
            ]
          },
          "program": "builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied",
          "depthStencilState": {
            "depthTest": true,
            "depthWrite": false
          },
          "properties": {
            "mainTexture": {
              "value": "grey",
              "type": 28
            },
            "mainTiling_Offset": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            },
            "frameTile_velLenScale": {
              "value": [
                1,
                1,
                0,
                0
              ],
              "type": 16
            }
          }
        }
      ]
    }
  ],
  "shaders": [
    {
      "hash": 2610855179,
      "glsl3": {
        "vert": "\nprecision highp float;\n\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nout vec2 uv;\nout vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nin vec3 a_position;\n\nin vec3 a_texCoord;\n\nin vec2 a_texCoord1;\n\nin vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  in vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  in vec3 a_texCoord2;\n\n  in vec3 a_normal;\n\n  in vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nin vec2 uv;\nin vec4 color;\n\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\n\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\n\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\n\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\n\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\n\nvarying vec2 uv;\nvarying vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nattribute vec3 a_position;\n\nattribute vec3 a_texCoord;\n\nattribute vec2 a_texCoord1;\n\nattribute vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  attribute vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  attribute vec3 a_texCoord2;\n\n  attribute vec3 a_normal;\n\n  attribute vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform vec4 cc_exposure;\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nvarying vec2 uv;\nvarying vec4 color;\n\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\n\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\n\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\n\nvoid main() { gl_FragColor = add(); }\n"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            }
          ],
          "samplers": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocal",
              "defines": []
            }
          ],
          "samplers": []
        }
      },
      "defines": [
        {
          "name": "CC_USE_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_STRETCHED_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HORIZONTAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_VERTICAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_MESH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_WORLD_SPACE",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HDR",
          "type": "boolean",
          "defines": []
        }
      ],
      "blocks": [
        {
          "name": "Constants",
          "members": [
            {
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            },
            {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            },
            {
              "name": "scale",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 0
        },
        {
          "name": "FragConstants",
          "members": [
            {
              "name": "tintColor",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 1
        }
      ],
      "samplers": [
        {
          "name": "mainTexture",
          "type": 28,
          "count": 1,
          "defines": [],
          "binding": 30
        }
      ],
      "dependencies": {},
      "name": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add"
    },
    {
      "hash": 1837721495,
      "glsl3": {
        "vert": "\nprecision highp float;\n\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nout vec2 uv;\nout vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nin vec3 a_position;\n\nin vec3 a_texCoord;\n\nin vec2 a_texCoord1;\n\nin vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  in vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  in vec3 a_texCoord2;\n\n  in vec3 a_normal;\n\n  in vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nin vec2 uv;\nin vec4 color;\n\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\n\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\n\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\n\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }\n"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\n\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\n\nvarying vec2 uv;\nvarying vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nattribute vec3 a_position;\n\nattribute vec3 a_texCoord;\n\nattribute vec2 a_texCoord1;\n\nattribute vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  attribute vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  attribute vec3 a_texCoord2;\n\n  attribute vec3 a_normal;\n\n  attribute vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform vec4 cc_exposure;\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nvarying vec2 uv;\nvarying vec4 color;\n\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\n\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\n\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\n\nvoid main() { gl_FragColor = multiply(); }\n"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            }
          ],
          "samplers": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocal",
              "defines": []
            }
          ],
          "samplers": []
        }
      },
      "defines": [
        {
          "name": "CC_USE_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_STRETCHED_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HORIZONTAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_VERTICAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_MESH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_WORLD_SPACE",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HDR",
          "type": "boolean",
          "defines": []
        }
      ],
      "blocks": [
        {
          "name": "Constants",
          "members": [
            {
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            },
            {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            },
            {
              "name": "scale",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 0
        },
        {
          "name": "FragConstants",
          "members": [
            {
              "name": "tintColor",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 1
        }
      ],
      "samplers": [
        {
          "name": "mainTexture",
          "type": 28,
          "count": 1,
          "defines": [],
          "binding": 30
        }
      ],
      "dependencies": {},
      "name": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply"
    },
    {
      "hash": 3233284501,
      "glsl3": {
        "vert": "\nprecision highp float;\n\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nout vec2 uv;\nout vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nin vec3 a_position;\n\nin vec3 a_texCoord;\n\nin vec2 a_texCoord1;\n\nin vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  in vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  in vec3 a_texCoord2;\n\n  in vec3 a_normal;\n\n  in vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nin vec2 uv;\nin vec4 color;\n\nuniform sampler2D mainTexture;\n\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\n\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\n\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }\n"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\n\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\n\nvarying vec2 uv;\nvarying vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nattribute vec3 a_position;\n\nattribute vec3 a_texCoord;\n\nattribute vec2 a_texCoord1;\n\nattribute vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  attribute vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  attribute vec3 a_texCoord2;\n\n  attribute vec3 a_normal;\n\n  attribute vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform vec4 cc_exposure;\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nvarying vec2 uv;\nvarying vec4 color;\n\nuniform sampler2D mainTexture;\n\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\n\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\n\nvoid main() { gl_FragColor = addSmooth(); }\n"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            }
          ],
          "samplers": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocal",
              "defines": []
            }
          ],
          "samplers": []
        }
      },
      "defines": [
        {
          "name": "CC_USE_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_STRETCHED_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HORIZONTAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_VERTICAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_MESH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_WORLD_SPACE",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HDR",
          "type": "boolean",
          "defines": []
        }
      ],
      "blocks": [
        {
          "name": "Constants",
          "members": [
            {
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            },
            {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            },
            {
              "name": "scale",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 0
        }
      ],
      "samplers": [
        {
          "name": "mainTexture",
          "type": 28,
          "count": 1,
          "defines": [],
          "binding": 30
        }
      ],
      "dependencies": {},
      "name": "builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth"
    },
    {
      "hash": 1066726376,
      "glsl3": {
        "vert": "\nprecision highp float;\n\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nout vec2 uv;\nout vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nin vec3 a_position;\n\nin vec3 a_texCoord;\n\nin vec2 a_texCoord1;\n\nin vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  in vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  in vec3 a_texCoord2;\n\n  in vec3 a_normal;\n\n  in vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nin vec2 uv;\nin vec4 color;\n\nuniform sampler2D mainTexture;\n\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\n\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\n\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }\n"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\n\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\n\nvarying vec2 uv;\nvarying vec4 color;\n\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\n\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\n\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\n\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\n\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\n\nattribute vec3 a_position;\n\nattribute vec3 a_texCoord;\n\nattribute vec2 a_texCoord1;\n\nattribute vec4 a_color;\n\n#if CC_USE_STRETCHED_BILLBOARD\n  attribute vec3 a_color1;\n\n#endif\n\n#if CC_USE_MESH\n  attribute vec3 a_texCoord2;\n\n  attribute vec3 a_normal;\n\n  attribute vec4 a_color1;\n\n#endif\n\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n\n  #if !CC_USE_WORLD_SPACE\n\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n\n  pos = cc_matViewProj * pos;\n\n  return pos;\n}\n\nvoid main() { gl_Position = lpvs_main(); }\n",
        "frag": "\nprecision highp float;\nuniform vec4 cc_exposure;\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nvarying vec2 uv;\nvarying vec4 color;\n\nuniform sampler2D mainTexture;\n\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\n\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\n\nvoid main() { gl_FragColor = premultiplied(); }\n"
      },
      "builtins": {
        "globals": {
          "blocks": [
            {
              "name": "CCGlobal",
              "defines": []
            }
          ],
          "samplers": []
        },
        "locals": {
          "blocks": [
            {
              "name": "CCLocal",
              "defines": []
            }
          ],
          "samplers": []
        }
      },
      "defines": [
        {
          "name": "CC_USE_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_STRETCHED_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HORIZONTAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_VERTICAL_BILLBOARD",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_MESH",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_WORLD_SPACE",
          "type": "boolean",
          "defines": []
        },
        {
          "name": "CC_USE_HDR",
          "type": "boolean",
          "defines": []
        }
      ],
      "blocks": [
        {
          "name": "Constants",
          "members": [
            {
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            },
            {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            },
            {
              "name": "scale",
              "type": 16,
              "count": 1
            }
          ],
          "defines": [],
          "binding": 0
        }
      ],
      "samplers": [
        {
          "name": "mainTexture",
          "type": 28,
          "count": 1,
          "defines": [],
          "binding": 30
        }
      ],
      "dependencies": {},
      "name": "builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied"
    }
  ]
}